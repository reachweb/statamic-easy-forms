<div 
    x-model="submitFields['{{ handle }}']"
    x-modelable="selectedDate"
    x-data="{
        selectedDate: '',
        showDatepicker: false,
        showYearPicker: false,
        
        // --- Configuration ---
        mode: '{{ if date_range }}range{{ else }}single{{ /if }}',
        
        // Static dates (Strings)
        configMinDateStr: '{{ min_date ?? "" }}',
        configMaxDateStr: '{{ max_date ?? "" }}',
        
        // Relative dates (Integers)
        configMinDateToday: {{ if min_date_today !== null }}{{ min_date_today }}{{ else }}null{{ /if }},
        configMaxDateToday: {{ if max_date_today !== null }}{{ max_date_today }}{{ else }}null{{ /if }},
        
        // Range limit
        maxRange: {{ max_range ?? 'null' }},

        // Close after selection (inverted logic - default is to close)
        dontCloseAfterSelection: {{ dont_close_after_selection ? 'true' : 'false' }},

        // --- Internal State ---
        dateFrom: null,
        dateTo: null,
        hoverDate: null,
        minDateObj: null,
        maxDateObj: null,
        month: '',
        year: '',
        no_of_days: [],
        blankdays: [],
        years: [],
        DAYS: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        MONTH_NAMES: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],

        init() {
            let today = new Date();
            today.setHours(0,0,0,0);

            // Calculate Minimum Date
            if (this.configMinDateToday !== null) {
                this.minDateObj = new Date(today);
                let offset = parseInt(this.configMinDateToday);
                this.minDateObj.setDate(today.getDate() + offset);
            } else if (this.configMinDateStr) {
                this.minDateObj = new Date(this.configMinDateStr);
            }
            if (this.minDateObj) this.minDateObj.setHours(0,0,0,0);

            // Calculate Maximum Date
            if (this.configMaxDateToday !== null) {
                this.maxDateObj = new Date(today);
                let offset = parseInt(this.configMaxDateToday);
                this.maxDateObj.setDate(today.getDate() + offset);
            } else if (this.configMaxDateStr) {
                this.maxDateObj = new Date(this.configMaxDateStr);
            }
            if (this.maxDateObj) this.maxDateObj.setHours(0,0,0,0);

            // Set initial view to Today (default)
            this.month = today.getMonth();
            this.year = today.getFullYear();
            
            // If minDate is in the future, shift view there
            if(this.minDateObj && this.minDateObj > today) {
                this.month = this.minDateObj.getMonth();
                this.year = this.minDateObj.getFullYear();
            }

            // Parse existing value (Overrides Today/MinDate view if value exists)
            this.parseSelectedDate();

            // Generate grid
            this.generateDays();
            this.generateYears();

            // Watch for changes to input (e.g. form reset or manual change)
            this.$watch('selectedDate', () => {
                this.parseSelectedDate();
                this.generateDays();
            });
        },

        // Restores state from the string value
        parseSelectedDate() {
            if (!this.selectedDate) {
                this.dateFrom = null;
                this.dateTo = null;
                return;
            }

            // Safe parser (avoids timezone shifts)
            const parse = (str) => {
                if(!str) return null;
                const [y, m, d] = str.split('-').map(Number);
                return new Date(y, m - 1, d);
            };

            if (this.mode === 'range' && this.selectedDate.includes(' - ')) {
                const parts = this.selectedDate.split(' - ');
                this.dateFrom = parse(parts[0]);
                this.dateTo = parse(parts[1]);
            } else {
                this.dateFrom = parse(this.selectedDate);
            }

            // Sync Calendar View to the selected date
            if (this.dateFrom) {
                this.month = this.dateFrom.getMonth();
                this.year = this.dateFrom.getFullYear();
            }
        },

        // --- Helper to determine the effective 'End Date' for styling (Actual or Hover) ---
        get effectiveEnd() {
            if (this.dateTo) return this.dateTo;
            if (this.dateFrom && this.hoverDate) return this.hoverDate;
            return null;
        },

        // --- Logic ---

        isAllowed(date) {
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);

            // Global Min/Max
            if (this.minDateObj && d < this.minDateObj) return false;
            if (this.maxDateObj && d > this.maxDateObj) return false;

            // Max Range Check (using effective end to show invalid state on hover)
            if (this.mode === 'range' && this.maxRange && this.dateFrom && !this.dateTo) {
                const diffTime = Math.abs(d - this.dateFrom);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
                if (diffDays >= this.maxRange) return false;
            }

            return true;
        },

        // Check if exact Start Date
        isStart(date) {
            if (!this.dateFrom) return false;
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            return d.getTime() === this.dateFrom.getTime();
        },

        // Check if exact End Date (or Hover End)
        isEnd(date) {
            const effective = this.effectiveEnd;
            if (!effective) return false;
            
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            
            // Handle backwards hover/selection
            const start = this.dateFrom < effective ? this.dateFrom : effective;
            const end = this.dateFrom < effective ? effective : this.dateFrom;

            return d.getTime() === end.getTime();
        },

        // Check if Start (for styling logic, handles swap)
        isVisualStart(date) {
            const effective = this.effectiveEnd;
            if (!this.dateFrom) return false;
            
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            
            if (!effective) return d.getTime() === this.dateFrom.getTime();

            const start = this.dateFrom < effective ? this.dateFrom : effective;
            return d.getTime() === start.getTime();
        },

        isInRange(date) {
            if (this.mode === 'single' || !this.dateFrom) return false;
            const effective = this.effectiveEnd;
            if (!effective) return false;

            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);

            // Sort dates to handle backwards selection
            const start = this.dateFrom < effective ? this.dateFrom : effective;
            const end = this.dateFrom < effective ? effective : this.dateFrom;

            return d > start && d < end;
        },

        getAriaLabel(date) {
            return date + ' ' + this.MONTH_NAMES[this.month] + ' ' + this.year;
        },

        selectDate(date) {
            if (!this.isAllowed(date)) return;

            let selectedDateObj = new Date(this.year, this.month, date);
            selectedDateObj.setHours(0,0,0,0);

            if (this.mode === 'single') {
                this.dateFrom = selectedDateObj;
                this.updateValue();
                if (!this.dontCloseAfterSelection) {
                    this.showDatepicker = false;
                }
            } else {
                if (!this.dateFrom || (this.dateFrom && this.dateTo)) {
                    // Start Selection
                    this.dateFrom = selectedDateObj;
                    this.dateTo = null;
                    this.hoverDate = null;
                } else {
                    // End Selection
                    if (selectedDateObj < this.dateFrom) {
                        if (this.maxRange) {
                            const diffTime = Math.abs(selectedDateObj - this.dateFrom);
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays >= this.maxRange) {
                                this.dateFrom = selectedDateObj;
                                this.dateTo = null;
                                return;
                            }
                        }
                        this.dateTo = this.dateFrom;
                        this.dateFrom = selectedDateObj;
                    } else {
                        this.dateTo = selectedDateObj;
                    }
                    this.updateValue();
                    if (!this.dontCloseAfterSelection) {
                        this.showDatepicker = false;
                    }
                    this.hoverDate = null;
                }
            }
        },

        updateValue() {
            const formatDate = (d) => {
                return d.getFullYear() + '-' + ('0'+ (d.getMonth() + 1)).slice(-2) + '-' + ('0' + d.getDate()).slice(-2);
            };

            if (this.mode === 'single' && this.dateFrom) {
                this.selectedDate = formatDate(this.dateFrom);
            } else if (this.mode === 'range' && this.dateFrom && this.dateTo) {
                this.selectedDate = formatDate(this.dateFrom) + ' - ' + formatDate(this.dateTo);
            }
        },

        resetDate() {
            this.dateFrom = null;
            this.dateTo = null;
            this.hoverDate = null;
            this.selectedDate = '';
        },

        changeMonth(step) {
            this.month += step;
            if (this.month < 0) { this.month = 11; this.year--; }
            if (this.month > 11) { this.month = 0; this.year++; }
            this.generateDays();
        },

        selectYear(newYear) {
            this.year = newYear;
            this.showYearPicker = false;
            this.generateDays();
        },

        generateDays() {
            let daysInMonth = new Date(this.year, this.month + 1, 0).getDate();
            let dayOfWeek = new Date(this.year, this.month).getDay();
            this.blankdays = Array.from({length: dayOfWeek}, (_, i) => i + 1);
            this.no_of_days = Array.from({length: daysInMonth}, (_, i) => i + 1);
        },

        generateYears() {
            let currentYear = new Date().getFullYear();
            for (let i = currentYear - 50; i <= currentYear + 10; i++) {
                this.years.push(i);
            }
        },

        setHover(date) {
            if (this.mode === 'range' && this.dateFrom && !this.dateTo) {
                 let d = new Date(this.year, this.month, date);
                 d.setHours(0,0,0,0);
                 this.hoverDate = d;
            }
        }
    }"
    class="relative w-full"
    x-on:click.outside="showDatepicker = false"
    x-on:keydown.escape="showDatepicker = false"
>
    <div class="relative">
        <div class="absolute inset-y-0 start-0 ps-2.5 flex items-center pointer-events-none" aria-hidden="true">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 text-gray-500">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5" />
            </svg>
        </div>

        <input 
            x-ref="dateInput"
            type="text"
            readonly
            x-model="selectedDate"
            x-on:click="showDatepicker = !showDatepicker"
            x-on:keydown.enter="showDatepicker = !showDatepicker"
            x-bind:aria-expanded="showDatepicker"
            aria-haspopup="dialog"
            aria-label="Choose date"
            placeholder="{{ placeholder ?? "Please select" | trans }}"
            class="form-input cursor-pointer bg-gray-50 border border-gray-300 text-gray-900 rounded-lg focus:border-form-main focus:ring-2 focus:ring-form-main focus:outline-none block w-full py-2.5 px-10"
        />

        <button
            type="button"
            x-show="selectedDate"
            x-on:click="resetDate()"
            x-cloak
            aria-label="Clear date"
            class="absolute inset-y-0 end-0 flex z-10 items-center pe-2.5 cursor-pointer text-form-main hover:text-gray-700 focus:outline-none focus:text-gray-900"
        >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M18 6l-12 12" /><path d="M6 6l12 12" />
            </svg>
        </button>
    </div>

    <div 
        x-show="showDatepicker"
        x-transition
        x-cloak
        role="dialog"
        aria-modal="true"
        aria-label="Calendar"
        class="absolute top-full mt-1 left-0 z-50 bg-white rounded-lg shadow-xl border border-gray-200 p-4 w-72"
    >
        <div class="flex justify-between items-center mb-4">
            <div>
                <span x-text="MONTH_NAMES[month]" class="text-base font-bold text-gray-800"></span>
                <button 
                    type="button"
                    x-text="year" 
                    x-on:click="showYearPicker = !showYearPicker"
                    aria-label="Select year"
                    class="ml-1 text-base text-gray-600 font-normal cursor-pointer hover:text-blue-600 hover:underline focus:outline-none focus:ring-2 focus:ring-blue-500 rounded px-1">
                </button>
            </div>
            <div>
                <button type="button" aria-label="Previous month" class="p-1 hover:bg-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500" x-on:click="changeMonth(-1)" x-bind:disabled="showYearPicker">
                    <svg class="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
                </button>
                <button type="button" aria-label="Next month" class="p-1 hover:bg-gray-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500" x-on:click="changeMonth(1)" x-bind:disabled="showYearPicker">
                    <svg class="h-5 w-5 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                </button>
            </div>
        </div>

        <div x-show="showYearPicker" class="h-64 overflow-y-auto grid grid-cols-4 gap-2">
            <template x-for="y in years" x-bind:key="y">
                <button 
                    type="button"
                    x-on:click="selectYear(y)" 
                    x-text="y" 
                    class="text-center text-sm py-2 rounded hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-blue-500" 
                    x-bind:class="{'bg-blue-500 text-white': year == y}"
                ></button>
            </template>
        </div>

        <div x-show="!showYearPicker">
            <div class="grid grid-cols-7 mb-2">
                <template x-for="day in DAYS" x-bind:key="day"> 
                    <div class="text-center text-xs font-medium text-gray-500" x-text="day"></div>
                </template>
            </div>

            <div class="grid grid-cols-7 gap-y-1">
                <template x-for="blank in blankdays">
                    <div class="p-1"></div>
                </template> 
                
                <template x-for="date in no_of_days" x-bind:key="date"> 
                    <button
                        type="button"
                        x-on:click="selectDate(date)"
                        x-on:mouseenter="setHover(date)"
                        x-text="date"
                        x-bind:disabled="!isAllowed(date)"
                        x-bind:aria-label="getAriaLabel(date)"
                        class="aspect-square w-full flex items-center justify-center text-sm transition-colors focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-blue-500"
                        x-bind:class="{
                            'text-gray-300 cursor-not-allowed opacity-50': !isAllowed(date),

                            // Single Date Mode or Exact Match Start & End (e.g. 1 day range) or Start without End
                            'bg-blue-600 text-white rounded-full': (mode === 'single' && isStart(date)) || (mode === 'range' && isStart(date) && !effectiveEnd) || (mode === 'range' && isVisualStart(date) && isEnd(date)),

                            // Range Start (Rounded Left only)
                            'bg-blue-600 text-white rounded-l-full rounded-r-none': mode === 'range' && isVisualStart(date) && effectiveEnd && !isEnd(date),

                            // Range End (Rounded Right only)
                            'bg-blue-600 text-white rounded-r-full rounded-l-none': mode === 'range' && isEnd(date) && isVisualStart(date) === false,

                            // In Range (Square)
                            'bg-blue-100 text-blue-800 rounded-none': isInRange(date),

                            // Hover states for unselected
                            'hover:bg-blue-100 text-gray-700 rounded-full': !isVisualStart(date) && !isEnd(date) && !isInRange(date) && isAllowed(date)
                        }"
                    ></button>
                </template>
            </div>
        </div>
    </div>
</div>