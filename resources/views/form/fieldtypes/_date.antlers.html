<div 
    x-model="submitFields['{{ handle }}']"
    x-modelable="selectedDate"
    x-data="{
        selectedDate: '',
        showDatepicker: false,
        showYearPicker: false,
        
        // --- Configuration ---
        mode: '{{ if date_range }}range{{ else }}single{{ /if }}',
        
        // Static dates (Strings)
        configMinDateStr: '{{ min_date ?? "" }}',
        configMaxDateStr: '{{ max_date ?? "" }}',
        
        // Relative dates (Integers)
        configMinDateToday: {{ if min_date_today !== null }}{{ min_date_today }}{{ else }}null{{ /if }},
        configMaxDateToday: {{ if max_date_today !== null }}{{ max_date_today }}{{ else }}null{{ /if }},
        
        // Range limit
        maxRange: {{ max_range ?? 'null' }},

        // Close after selection (inverted logic - default is to close)
        dontCloseAfterSelection: {{ dont_close_after_selection ? 'true' : 'false' }},

        // --- Internal State ---
        dateFrom: null,
        dateTo: null,
        hoverDate: null,
        minDateObj: null,
        maxDateObj: null,
        month: '',
        year: '',
        no_of_days: [],
        blankdays: [],
        years: [],
        DAYS: ['{{ "Sun" | trans }}', '{{ "Mon" | trans }}', '{{ "Tue" | trans }}', '{{ "Wed" | trans }}', '{{ "Thu" | trans }}', '{{ "Fri" | trans }}', '{{ "Sat" | trans }}'],
        MONTH_NAMES: ['{{ "January" | trans }}', '{{ "February" | trans }}', '{{ "March" | trans }}', '{{ "April" | trans }}', '{{ "May" | trans }}', '{{ "June" | trans }}', '{{ "July" | trans }}', '{{ "August" | trans }}', '{{ "September" | trans }}', '{{ "October" | trans }}', '{{ "November" | trans }}', '{{ "December" | trans }}'],
        focusedDate: null,

        init() {
            let today = new Date();
            today.setHours(0,0,0,0);

            // Calculate Minimum Date
            if (this.configMinDateToday !== null) {
                this.minDateObj = new Date(today);
                let offset = parseInt(this.configMinDateToday);
                this.minDateObj.setDate(today.getDate() + offset);
            } else if (this.configMinDateStr) {
                this.minDateObj = new Date(this.configMinDateStr);
            }
            if (this.minDateObj) this.minDateObj.setHours(0,0,0,0);

            // Calculate Maximum Date
            if (this.configMaxDateToday !== null) {
                this.maxDateObj = new Date(today);
                let offset = parseInt(this.configMaxDateToday);
                this.maxDateObj.setDate(today.getDate() + offset);
            } else if (this.configMaxDateStr) {
                this.maxDateObj = new Date(this.configMaxDateStr);
            }
            if (this.maxDateObj) this.maxDateObj.setHours(0,0,0,0);

            // Set initial view to Today (default)
            this.month = today.getMonth();
            this.year = today.getFullYear();
            
            // If minDate is in the future, shift view there
            if(this.minDateObj && this.minDateObj > today) {
                this.month = this.minDateObj.getMonth();
                this.year = this.minDateObj.getFullYear();
            }

            // Parse existing value (Overrides Today/MinDate view if value exists)
            this.parseSelectedDate();

            // Generate grid
            this.generateDays();
            this.generateYears();

            // Watch for changes to input (e.g. form reset or manual change)
            this.$watch('selectedDate', () => {
                this.parseSelectedDate();
                this.generateDays();
            });
        },

        // Restores state from the string value
        parseSelectedDate() {
            if (!this.selectedDate) {
                this.dateFrom = null;
                this.dateTo = null;
                return;
            }

            // Safe parser (avoids timezone shifts)
            const parse = (str) => {
                if(!str) return null;
                const [y, m, d] = str.split('-').map(Number);
                return new Date(y, m - 1, d);
            };

            if (this.mode === 'range' && this.selectedDate.includes(' - ')) {
                const parts = this.selectedDate.split(' - ');
                this.dateFrom = parse(parts[0]);
                this.dateTo = parse(parts[1]);
            } else {
                this.dateFrom = parse(this.selectedDate);
            }

            // Sync Calendar View to the selected date
            if (this.dateFrom) {
                this.month = this.dateFrom.getMonth();
                this.year = this.dateFrom.getFullYear();
            }
        },

        // --- Helper to determine the effective 'End Date' for styling (Actual or Hover) ---
        get effectiveEnd() {
            if (this.dateTo) return this.dateTo;
            if (this.dateFrom && this.hoverDate) return this.hoverDate;
            return null;
        },

        // --- Logic ---

        isAllowed(date) {
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);

            // Global Min/Max
            if (this.minDateObj && d < this.minDateObj) return false;
            if (this.maxDateObj && d > this.maxDateObj) return false;

            // Max Range Check (using effective end to show invalid state on hover)
            if (this.mode === 'range' && this.maxRange && this.dateFrom && !this.dateTo) {
                const diffTime = Math.abs(d - this.dateFrom);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
                if (diffDays >= this.maxRange) return false;
            }

            return true;
        },

        // Check if exact Start Date
        isStart(date) {
            if (!this.dateFrom) return false;
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            return d.getTime() === this.dateFrom.getTime();
        },

        // Check if exact End Date (or Hover End)
        isEnd(date) {
            const effective = this.effectiveEnd;
            if (!effective) return false;
            
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            
            // Handle backwards hover/selection
            const start = this.dateFrom < effective ? this.dateFrom : effective;
            const end = this.dateFrom < effective ? effective : this.dateFrom;

            return d.getTime() === end.getTime();
        },

        // Check if Start (for styling logic, handles swap)
        isVisualStart(date) {
            const effective = this.effectiveEnd;
            if (!this.dateFrom) return false;
            
            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);
            
            if (!effective) return d.getTime() === this.dateFrom.getTime();

            const start = this.dateFrom < effective ? this.dateFrom : effective;
            return d.getTime() === start.getTime();
        },

        isInRange(date) {
            if (this.mode === 'single' || !this.dateFrom) return false;
            const effective = this.effectiveEnd;
            if (!effective) return false;

            const d = new Date(this.year, this.month, date);
            d.setHours(0,0,0,0);

            // Sort dates to handle backwards selection
            const start = this.dateFrom < effective ? this.dateFrom : effective;
            const end = this.dateFrom < effective ? effective : this.dateFrom;

            return d > start && d < end;
        },

        getAriaLabel(date) {
            return date + ' ' + this.MONTH_NAMES[this.month] + ' ' + this.year;
        },

        selectDate(date) {
            if (!this.isAllowed(date)) return;

            let selectedDateObj = new Date(this.year, this.month, date);
            selectedDateObj.setHours(0,0,0,0);

            if (this.mode === 'single') {
                this.dateFrom = selectedDateObj;
                this.updateValue();
                if (!this.dontCloseAfterSelection) {
                    this.showDatepicker = false;
                }
            } else {
                if (!this.dateFrom || (this.dateFrom && this.dateTo)) {
                    // Start Selection
                    this.dateFrom = selectedDateObj;
                    this.dateTo = null;
                    this.hoverDate = null;
                } else {
                    // End Selection
                    if (selectedDateObj < this.dateFrom) {
                        if (this.maxRange) {
                            const diffTime = Math.abs(selectedDateObj - this.dateFrom);
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays >= this.maxRange) {
                                this.dateFrom = selectedDateObj;
                                this.dateTo = null;
                                return;
                            }
                        }
                        this.dateTo = this.dateFrom;
                        this.dateFrom = selectedDateObj;
                    } else {
                        this.dateTo = selectedDateObj;
                    }
                    this.updateValue();
                    if (!this.dontCloseAfterSelection) {
                        this.showDatepicker = false;
                    }
                    this.hoverDate = null;
                }
            }
        },

        updateValue() {
            const formatDate = (d) => {
                return d.getFullYear() + '-' + ('0'+ (d.getMonth() + 1)).slice(-2) + '-' + ('0' + d.getDate()).slice(-2);
            };

            if (this.mode === 'single' && this.dateFrom) {
                this.selectedDate = formatDate(this.dateFrom);
            } else if (this.mode === 'range' && this.dateFrom && this.dateTo) {
                this.selectedDate = formatDate(this.dateFrom) + ' - ' + formatDate(this.dateTo);
            }
        },

        resetDate() {
            this.dateFrom = null;
            this.dateTo = null;
            this.hoverDate = null;
            this.selectedDate = '';
        },

        changeMonth(step) {
            this.month += step;
            if (this.month < 0) { this.month = 11; this.year--; }
            if (this.month > 11) { this.month = 0; this.year++; }
            this.generateDays();
        },

        selectYear(newYear) {
            this.year = newYear;
            this.showYearPicker = false;
            this.generateDays();
        },

        generateDays() {
            let daysInMonth = new Date(this.year, this.month + 1, 0).getDate();
            let dayOfWeek = new Date(this.year, this.month).getDay();
            this.blankdays = Array.from({length: dayOfWeek}, (_, i) => i + 1);
            this.no_of_days = Array.from({length: daysInMonth}, (_, i) => i + 1);
        },

        generateYears() {
            let currentYear = new Date().getFullYear();
            for (let i = currentYear - 50; i <= currentYear + 10; i++) {
                this.years.push(i);
            }
        },

        setHover(date) {
            if (this.mode === 'range' && this.dateFrom && !this.dateTo) {
                 let d = new Date(this.year, this.month, date);
                 d.setHours(0,0,0,0);
                 this.hoverDate = d;
            }
        },

        handleKeyboardNavigation(event, currentDate) {
            const key = event.key;

            // Set focused date if not set
            if (this.focusedDate === null) {
                this.focusedDate = currentDate;
            }

            let newFocusedDate = this.focusedDate;
            let changeMonth = 0;

            switch(key) {
                case 'ArrowRight':
                    event.preventDefault();
                    newFocusedDate++;
                    if (newFocusedDate > this.no_of_days.length) {
                        newFocusedDate = 1;
                        changeMonth = 1;
                    }
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    newFocusedDate--;
                    if (newFocusedDate < 1) {
                        changeMonth = -1;
                        const prevMonth = this.month === 0 ? 11 : this.month - 1;
                        const prevYear = this.month === 0 ? this.year - 1 : this.year;
                        newFocusedDate = new Date(prevYear, prevMonth + 1, 0).getDate();
                    }
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    newFocusedDate += 7;
                    if (newFocusedDate > this.no_of_days.length) {
                        changeMonth = 1;
                        newFocusedDate = newFocusedDate - this.no_of_days.length;
                    }
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    newFocusedDate -= 7;
                    if (newFocusedDate < 1) {
                        changeMonth = -1;
                        const prevMonth = this.month === 0 ? 11 : this.month - 1;
                        const prevYear = this.month === 0 ? this.year - 1 : this.year;
                        const daysInPrevMonth = new Date(prevYear, prevMonth + 1, 0).getDate();
                        newFocusedDate = daysInPrevMonth + newFocusedDate;
                    }
                    break;
                case 'Home':
                    event.preventDefault();
                    newFocusedDate = 1;
                    break;
                case 'End':
                    event.preventDefault();
                    newFocusedDate = this.no_of_days.length;
                    break;
                case 'PageUp':
                    event.preventDefault();
                    changeMonth = event.shiftKey ? -12 : -1;
                    break;
                case 'PageDown':
                    event.preventDefault();
                    changeMonth = event.shiftKey ? 12 : 1;
                    break;
                case 'Enter':
                case ' ':
                    event.preventDefault();
                    this.selectDate(this.focusedDate);
                    return;
                case 'Escape':
                    event.preventDefault();
                    this.showDatepicker = false;
                    this.$refs.dateInput.focus();
                    return;
                default:
                    return;
            }

            if (changeMonth !== 0) {
                this.changeMonth(changeMonth);
                this.$nextTick(() => {
                    // Clamp to valid dates in new month
                    if (newFocusedDate > this.no_of_days.length) {
                        newFocusedDate = this.no_of_days.length;
                    }
                    this.focusedDate = newFocusedDate;
                    this.focusDateButton(newFocusedDate);
                });
            } else {
                this.focusedDate = newFocusedDate;
                this.focusDateButton(newFocusedDate);
            }
        },

        focusDateButton(date) {
            this.$nextTick(() => {
                const button = this.$el.querySelector('[data-date=\'' + date + '\']');
                if (button && !button.disabled) {
                    button.focus();
                }
            });
        },

        initFocusOnOpen() {
            this.$nextTick(() => {
                // Focus the selected date or today's date
                let initialFocus = this.dateFrom ? this.dateFrom.getDate() : new Date().getDate();

                // If we're viewing a different month, focus the 1st
                if (this.dateFrom && (this.dateFrom.getMonth() !== this.month || this.dateFrom.getFullYear() !== this.year)) {
                    initialFocus = 1;
                }

                this.focusedDate = initialFocus;
                this.focusDateButton(initialFocus);
            });
        }
    }"
    class="relative w-full"
    x-on:click.outside="showDatepicker = false"
    x-on:keydown.escape="showDatepicker = false"
>
    <div class="relative">
        <div class="absolute inset-y-0 start-0 ps-2.5 flex items-center pointer-events-none" aria-hidden="true">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 text-ef-icon">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0v-7.5A2.25 2.25 0 0 1 5.25 9h13.5A2.25 2.25 0 0 1 21 11.25v7.5" />
            </svg>
        </div>

        <input
            x-ref="dateInput"
            type="text"
            readonly
            x-model="selectedDate"
            x-on:click="showDatepicker = !showDatepicker; if(showDatepicker) initFocusOnOpen()"
            x-on:keydown.space.prevent="showDatepicker = !showDatepicker; if(showDatepicker) initFocusOnOpen()"
            x-bind:aria-expanded="showDatepicker"
            aria-haspopup="dialog"
            aria-label="Choose date"
            placeholder="{{ placeholder ?? "Please select" | trans }}"
            class="form-input cursor-pointer bg-ef-input-bg border border-ef-border text-ef-input-text rounded-ef focus:border-ef-focus focus:ring-2 focus:ring-ef-focus focus:outline-none block w-full py-2.5 px-10"
        />

        <button
            type="button"
            x-show="selectedDate"
            x-on:click="resetDate()"
            x-cloak
            aria-label="Clear date"
            class="absolute inset-y-0 end-0 flex z-10 items-center pe-2.5 cursor-pointer text-ef-accent hover:text-ef-text-muted focus:outline-none focus:text-ef-text"
        >
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M18 6l-12 12" /><path d="M6 6l12 12" />
            </svg>
        </button>
    </div>

    <div
        x-show="showDatepicker"
        x-transition
        x-cloak
        role="dialog"
        aria-modal="true"
        aria-label="Calendar"
        class="absolute top-full mt-1 left-0 z-50 bg-ef-text-white rounded-ef shadow-xl border border-ef-border p-4 w-72"
    >
        <div class="flex justify-between items-center mb-4">
            <div>
                <span x-text="MONTH_NAMES[month]" class="text-base font-bold text-ef-text"></span>
                <button
                    type="button"
                    x-text="year"
                    x-on:click="showYearPicker = !showYearPicker"
                    aria-label="Select year"
                    class="ml-1 text-base text-ef-text-muted font-normal cursor-pointer hover:text-ef-accent hover:underline focus:outline-none focus:ring-2 focus:ring-ef-focus rounded px-1">
                </button>
            </div>
            <div>
                <button type="button" aria-label="Previous month" class="p-1 hover:bg-ef-subtle rounded-full focus:outline-none focus:ring-2 focus:ring-ef-focus" x-on:click="changeMonth(-1)" x-bind:disabled="showYearPicker">
                    <svg class="h-5 w-5 text-ef-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
                </button>
                <button type="button" aria-label="Next month" class="p-1 hover:bg-ef-subtle rounded-full focus:outline-none focus:ring-2 focus:ring-ef-focus" x-on:click="changeMonth(1)" x-bind:disabled="showYearPicker">
                    <svg class="h-5 w-5 text-ef-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                </button>
            </div>
        </div>

        <div x-show="showYearPicker" class="h-64 overflow-y-auto grid grid-cols-4 gap-2">
            <template x-for="y in years" x-bind:key="y">
                <button
                    type="button"
                    x-on:click="selectYear(y)"
                    x-text="y"
                    class="text-center text-ef py-2 rounded hover:bg-ef-subtle focus:outline-none focus:ring-2 focus:ring-ef-focus"
                    x-bind:class="{'bg-ef-accent text-ef-text-white': year == y}"
                ></button>
            </template>
        </div>

        <div x-show="!showYearPicker">
            <div class="grid grid-cols-7 mb-2">
                <template x-for="day in DAYS" x-bind:key="day">
                    <div class="text-center text-ef-xs font-medium text-ef-text-muted" x-text="day"></div>
                </template>
            </div>

            <div class="grid grid-cols-7 gap-y-1" x-on:keydown="if (focusedDate) handleKeyboardNavigation($event, focusedDate)">
                <template x-for="blank in blankdays">
                    <div class="p-1"></div>
                </template>

                <template x-for="date in no_of_days" x-bind:key="date">
                    <button
                        type="button"
                        x-on:click="selectDate(date)"
                        x-on:mouseenter="setHover(date)"
                        x-on:focus="focusedDate = date"
                        x-bind:data-date="date"
                        x-bind:tabindex="focusedDate === date ? 0 : -1"
                        x-text="date"
                        x-bind:disabled="!isAllowed(date)"
                        x-bind:aria-label="getAriaLabel(date)"
                        class="aspect-square w-full flex items-center justify-center text-ef transition-colors focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-ef-focus"
                        x-bind:class="{
                            'text-ef-disabled cursor-not-allowed opacity-50': !isAllowed(date),

                            // Single Date Mode or Exact Match Start & End (e.g. 1 day range) or Start without End
                            'bg-ef-accent text-ef-text-white rounded-full': (mode === 'single' && isStart(date)) || (mode === 'range' && isStart(date) && !effectiveEnd) || (mode === 'range' && isVisualStart(date) && isEnd(date)),

                            // Range Start (Rounded Left only)
                            'bg-ef-accent text-ef-text-white rounded-l-full rounded-r-none': mode === 'range' && isVisualStart(date) && effectiveEnd && !isEnd(date),

                            // Range End (Rounded Right only)
                            'bg-ef-accent text-ef-text-white rounded-r-full rounded-l-none': mode === 'range' && isEnd(date) && isVisualStart(date) === false,

                            // In Range (Square)
                            'bg-ef-subtle text-ef-text rounded-none': isInRange(date),

                            // Hover states for unselected
                            'hover:bg-ef-subtle text-ef-text-muted rounded-full': !isVisualStart(date) && !isEnd(date) && !isInRange(date) && isAllowed(date)
                        }"
                    ></button>
                </template>
            </div>
        </div>
    </div>
</div>